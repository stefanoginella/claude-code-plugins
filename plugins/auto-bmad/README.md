# ğŸ¤– Auto BMAD

[![Plugin](https://img.shields.io/badge/Claude_Code-Plugin-blueviolet)](https://docs.anthropic.com/en/docs/claude-code) [![BMAD Method](https://img.shields.io/badge/BMAD-Method-orange)](https://github.com/bmad-code-org/BMAD-METHOD)

Automated (and very opinionated) BMAD pipeline orchestration for Claude Code.

Four sequential pipeline commands that drive the BMAD software development lifecycle â€” from planning through story delivery â€” plus a safe-bash auto-approval hook for frictionless autonomous execution.

> ğŸ‘€ The pipelines are quite long and token hungry (the story pipeline alone can run for more than 60 minutes). Some steps might seem redundant, but I am satisfied with the code quality and consistency I get out of this. I recommend having a Claude Code Max x5 or x20 subscription to not hit limits mid-run.

## ğŸš€ Commands

| Command | Steps | Description |
|---------|-------|-------------|
| `/auto-bmad-plan` | 11 | Pre-implementation pipeline: product brief, PRD, validate, UX, architecture, test framework, test design, epics, readiness, project context, sprint planning |
| `/auto-bmad-epic-start` | 1 | Start a new epic: epic-level test design |
| `/auto-bmad-story` | 12 | Develop a story: create, validate, ATDD, develop, 3x code review, NFR, E2E, trace, automate, test review |
| `/auto-bmad-epic-end` | 3 | Close an epic: trace, retrospective, project context refresh |

## ğŸ—‚ Artifacts

The pipelines produce the following key artifacts throughout the lifecycle:

| Pipeline | Artifacts |
|----------|-----------|
| **Plan** | Product brief, PRD, UX design, architecture doc, test framework, CI configuration, epics, test design, sprint plan |
| **Epic Start** | Retro action resolution log, green baseline report, story order plan |
| **Story** | Story file, ATDD specs, implementation code, code review report, security scan results, regression/E2E results, traceability entries |
| **Epic End** | Aggregated epic data, traceability gate report, retrospective, next epic preview |

## ğŸ›  Typical Workflow

This is what a complete workflow using the pipelines might look like. If you already have all the planning artifacts ready, you can skip the plan pipeline and go directly to step 4 or 5.

1. **Prepare a strong and comprehensive input** for the plan pipeline â€” it validates readiness and won't run with a simple `Create a todo app` prompt. I recommend going through a few `/bmad-brainstorming` and `/bmad-party-mode` sessions first to build up enough context. If the initial input isn't ready, the plan pipeline will tell you what to improve.
2. **Run `/auto-bmad-plan`** to kick off the initial planning pipeline for a new project or major initiative. This sets up the overall architecture, test framework, CI configuration, and initial epics and stories.
3. **Review the PRD, Architecture, UX design, Epics, and Test Plan** generated by the plan pipeline. Make sure they look good and adjust if necessary before moving on to implementation. You might want to go through a few iterations of `/bmad-party-mode` to refine the output, since it sets the foundation for the next steps.
4. **For each new epic**, run `/auto-bmad-epic-start` to establish a baseline and plan the story order based on the epic's goals and dependencies.
5. **For each story within an epic**, run `/auto-bmad-story` to develop the story from creation through delivery, including validation, ATDD, development, linting, testing, code review, security scanning, regression, E2E, and traceability.
6. **After each story**, review the report generated by the story pipeline and any other BMAD artifacts, perform some manual testing, and correct course if necessary.
7. **At the end of an epic**, run `/auto-bmad-epic-end` to close the epic, aggregate data, perform a traceability gate, conduct a retrospective, and preview the next epic.
8. **Review the outputs of each pipeline run**, check the generated artifacts, and make adjustments as needed. The pipelines are opinionated and automated, but they still require human judgment and iteration. Use `/bmad-bmm-correct-course` when big changes are needed.

> â„¹ï¸ **Important**: This plugin won't automate a multi-story workflow or an entire epic. Some human orchestration and judgment is still required between pipeline runs.

## ğŸ“¦ Installation

One-command install via npx:

```bash
npx @stefanoginella/auto-bmad
```

Or from the marketplace inside Claude Code:

```
/plugin marketplace add stefanoginella/claude-code-plugins
/plugin install auto-bmad@stefanoginella-plugins --scope <project|user|local>
```

Scopes: `project` (shared with team), `user` (all your projects), `local` (personal, gitignored).

Or as a local plugin for development:

```bash
claude --plugin-dir /path/to/plugins/auto-bmad
```

## ğŸ“‹ Prerequisites

> âš ï¸ **IMPORTANT**: Without these, the pipelines might fail or produce incorrect results. Make sure they're in place before running the pipelines.

### BMAD Method

The pipelines are based on the [BMAD Method](https://github.com/bmad-code-org/BMAD-METHOD) workflow and relies on specific BMAD modules.

#### Required BMAD Modules

- **TEA** â€” Test Engineering Architect. Provides test strategy, test design, and ATDD capabilities used throughout the pipelines.

#### Optional BMAD Modules

- **CIS** â€” Creative Intelligence Suite. Enhances UX design quality during the plan pipeline. Without it, UX steps use baseline prompts.

### Optional (but recommended) Claude Code Plugins

From the [`anthropics/claude-plugins-official`](https://github.com/anthropics/claude-plugins-official) marketplace.

- **context7** â€” Live documentation lookups for library APIs. Used during architecture creation (plan) and story development (story). Without it, agents rely on training data instead of current docs.
- **semgrep** â€” Security scanning in the story pipeline. Without it, the security scan step is skipped.
- **security-guidance** â€” Security best practice recommendations during story development.
- Any relevant `lsp` plugin(s) for your codebase â€” used during story development for linting and test feedback. They can improve the code quality and feedback loop, but are not strictly required since the pipelines also include manual lint and test steps.

### Required and optional CLI tools

- `jq` (required) - JSON processing in bash steps. Needed by the pipelines and the safe bash auto-approval hook.
- `semgrep` (optional) - security scanning. Needed if you have the semgrep plugin and want to run the security scan step in the story pipeline.
- Any relevant CLI tool (optional) needed by your LSP plugin(s).

### Project Requirements

The pipelines expect BMAD configuration files in the project:

- `_bmad/bmm/config.yaml` â€” BMM configuration (output folders, artifact paths)
- `_bmad/tea/config.yaml` â€” TEA configuration (test artifact paths)

These files are normally created by the BMAD CLI when initializing BMAD in a project. The pipelines rely on the standard structure and paths defined by these configs, so custom configurations may require pipeline adjustments.

## ğŸ”’ Hooks

### Safe Bash Auto-Approval (PreToolUse)

Auto-approves bash commands matching a known-safe and non-destructive prefix list to reduce false-positive sandbox prompts during autonomous pipeline execution. This is a lightweight heuristic, not a full sandbox bypass.

**Default safe list:**

| Group | Match | Commands |
|-------|-------|----------|
| **Git** | Exact | `git diff` Â· `git fetch` Â· `git log` Â· `git status` |
| | Prefix | `git -C` Â· `git add` Â· `git commit` Â· `git diff` Â· `git diff-tree` Â· `git fetch` Â· `git log` Â· `git rev-parse` Â· `git show` Â· `git status` Â· `git tag` |
| **Docker & Compose** | Exact | `docker compose build` Â· `docker compose config` Â· `docker compose down` Â· `docker compose images` Â· `docker compose logs` Â· `docker compose ls` Â· `docker compose ps` Â· `docker compose pull` Â· `docker compose top` Â· `docker compose up` Â· `docker compose version` Â· `docker images` Â· `docker ps` Â· `docker version` |
| | Prefix | `docker compose build` Â· `docker compose config` Â· `docker compose exec` Â· `docker compose logs` Â· `docker compose ps` Â· `docker compose pull` Â· `docker compose top` Â· `docker compose up` Â· `docker inspect` Â· `docker logs` Â· `docker ps` |
| **File reading** | Prefix | `cat` Â· `file` Â· `head` Â· `stat` Â· `tail` Â· `wc` |
| **File system** | Prefix | `chmod` Â· `cp` Â· `mkdir` Â· `mv` Â· `touch` |
| **Search & filtering** | Prefix | `find` Â· `grep` Â· `sort` Â· `uniq` |
| **Text processing** | Prefix | `awk` Â· `cut` Â· `diff` Â· `echo` Â· `jq` Â· `sed` Â· `tr` |
| **Path utilities** | Prefix | `basename` Â· `dirname` Â· `realpath` |
| **Directory listing** | Exact | `ls` Â· `pwd` Â· `tree` |
| | Prefix | `ls` Â· `tree` |
| **System & environment** | Exact | `date` Â· `uname` |
| | Prefix | `date` Â· `du` Â· `timeout` Â· `uname` Â· `which` |
| **Security scanning** | Prefix | `semgrep` |

**Customizing the safe list:** Create `.claude/auto-bmad-safe-prefixes.txt` in your project to add entries without modifying the plugin:

```
# Lines starting with "= " are exact matches (bare commands)
# All other lines are prefix matches (must end with a trailing space)
# Empty lines and comments (#) are ignored

= docker compose restart
npm install
npx vitest
```

## ğŸ” Permissions

The pipelines run various bash commands (depending on the project), skills and MCP that Claude Code will prompt you to approve if they are not already approved.

Many bash commands are already pre-approved by the safe bash auto-approval hook, but some might still require manual approval, especially if you have custom steps or a unique project setup that involves commands not in the default safe list. For the first few runs in a new project, expect several approval prompts as the allow list builds up. After that, things stabilize and the pipelines run fully autonomously.

> âš ï¸ Alternatively, you can run Claude Code in "dangerously skip permissions" mode (`--dangerously-skip-permissions`), but do so at your own risk â€” this disables **all** permission checks, not just the ones above. Only use it in an isolated environment like a VM or container.

## ğŸ“„ License

[MIT](../../LICENSE)
